--- origsrc/sqlite-3.6.3/tool/lemon.c	2008-08-26 07:24:53.000000000 -0500
+++ src/sqlite-3.6.3/tool/lemon.c	2008-09-26 02:29:17.853771000 -0500
@@ -1324,15 +1324,15 @@
   va_start(ap, format);
   /* Prepare a prefix to be prepended to every output line */
   if( lineno>0 ){
-    sprintf(prefix,"%.*s:%d: ",PREFIXLIMIT-10,filename,lineno);
+    snprintf(prefix,sizeof prefix,"%.*s:%d: ",PREFIXLIMIT-10,filename,lineno);
   }else{
-    sprintf(prefix,"%.*s: ",PREFIXLIMIT-10,filename);
+    snprintf(prefix,sizeof prefix,"%.*s: ",PREFIXLIMIT-10,filename);
   }
   prefixsize = lemonStrlen(prefix);
   availablewidth = LINEWIDTH - prefixsize;
 
   /* Generate the error message */
-  vsprintf(errmsg,format,ap);
+  vsnprintf(errmsg,sizeof errmsg,format,ap);
   va_end(ap);
   errmsgsize = lemonStrlen(errmsg);
   /* Remove trailing '\n's from the error message. */
@@ -2911,7 +2911,7 @@
     while( cfp ){
       char buf[20];
       if( cfp->dot==cfp->rp->nrhs ){
-        sprintf(buf,"(%d)",cfp->rp->index);
+        snprintf(buf,sizeof buf,"(%d)",cfp->rp->index);
         fprintf(fp,"    %5s ",buf);
       }else{
         fprintf(fp,"          ");
@@ -2966,6 +2966,7 @@
 {
   char *pathlist;
   char *path,*cp;
+  size_t pathsz;
   char c;
 
 #ifdef __WIN32__
@@ -2976,21 +2977,21 @@
   if( cp ){
     c = *cp;
     *cp = 0;
-    path = (char *)malloc( lemonStrlen(argv0) + lemonStrlen(name) + 2 );
-    if( path ) sprintf(path,"%s/%s",argv0,name);
+    path = (char *)malloc( (pathsz = lemonStrlen(argv0) + lemonStrlen(name) + 2) );
+    if( path ) snprintf(path,pathsz,"%s/%s",argv0,name);
     *cp = c;
   }else{
     extern char *getenv();
     pathlist = getenv("PATH");
     if( pathlist==0 ) pathlist = ".:/bin:/usr/bin";
-    path = (char *)malloc( lemonStrlen(pathlist)+lemonStrlen(name)+2 );
+    path = (char *)malloc( (pathsz = lemonStrlen(pathlist)+lemonStrlen(name)+2) );
     if( path!=0 ){
       while( *pathlist ){
         cp = strchr(pathlist,':');
         if( cp==0 ) cp = &pathlist[lemonStrlen(pathlist)];
         c = *cp;
         *cp = 0;
-        sprintf(path,"%s/%s",pathlist,name);
+        snprintf(path,pathsz,"%s/%s",pathlist,name);
         *cp = c;
         if( c==0 ) pathlist = "";
         else pathlist = &cp[1];
@@ -3070,14 +3071,16 @@
 
   cp = strrchr(lemp->filename,'.');
   if( cp ){
-    sprintf(buf,"%.*s.lt",(int)(cp-lemp->filename),lemp->filename);
+    snprintf(buf,sizeof buf,"%.*s.lt",(int)(cp-lemp->filename),lemp->filename);
   }else{
-    sprintf(buf,"%s.lt",lemp->filename);
+    snprintf(buf,sizeof buf,"%s.lt",lemp->filename);
   }
   if( access(buf,004)==0 ){
     tpltname = buf;
   }else if( access(templatename,004)==0 ){
     tpltname = templatename;
+  }else if( access("/usr/share/lemon/lempar.c",004)==0 ){
+    tpltname = "/usr/share/lemon/lempar.c";
   }else{
     tpltname = pathsearch(lemp->argv0,templatename,0);
   }
@@ -3089,7 +3092,7 @@
   }
   in = fopen(tpltname,"rb");
   if( in==0 ){
-    fprintf(stderr,"Can't open the template file \"%s\".\n",templatename);
+    fprintf(stderr,"Can't open the template file \"%s\".\n",tpltname);
     lemp->errorcnt++;
     return 0;
   }
@@ -3827,7 +3831,7 @@
   /* Generate a table containing the symbolic name of every symbol
   */
   for(i=0; i<lemp->nsymbol; i++){
-    sprintf(line,"\"%s\",",lemp->symbols[i]->name);
+    snprintf(line,sizeof line,"\"%s\",",lemp->symbols[i]->name);
     fprintf(out,"  %-15s",line);
     if( (i&3)==3 ){ fprintf(out,"\n"); lineno++; }
   }
@@ -3983,7 +3986,7 @@
   in = file_open(lemp,".h","rb");
   if( in ){
     for(i=1; i<lemp->nterminal && fgets(line,LINESIZE,in); i++){
-      sprintf(pattern,"#define %s%-30s %2d\n",prefix,lemp->symbols[i]->name,i);
+      snprintf(pattern,sizeof pattern,"#define %s%-30s %2d\n",prefix,lemp->symbols[i]->name,i);
       if( strcmp(line,pattern) ) break;
     }
     fclose(in);
--- origsrc/sqlite-3.6.3/debian/lemon.1
+++ origsrc/sqlite-3.6.3/debian/lemon.1
@@ -0,0 +1,63 @@
+.Dd 2002-10-04
+.Dt LEMON 1
+.Os "Debian GNU/Linux"
+.\" Manual page created by Guus Sliepen <guus@debian.org>
+.Sh NAME
+.Nm lemon
+.Nd The Lemon Parser Generator
+.Sh SYNOPSIS
+.Nm
+.Op Fl bcgmqsx
+.Ar input
+.Sh DESCRIPTION
+.Nm
+is an LALR(1) parser generator for C or C++.
+It does the same job as bison and yacc.
+But 
+.Nm
+is not another bison or yacc clone.
+It uses a different grammar syntax which is designed to reduce the number of coding errors.
+.Nm
+also uses a more sophisticated parsing engine that is faster than yacc and bison
+and which is both reentrant and thread-safe.
+Furthermore, 
+.Nm
+implements features that can be used to eliminate resource leaks,
+making is suitable for use in long-running programs such as graphical user interfaces or embedded controllers.
+.Pp
+.Nm
+will read the grammer from
+.Ar input
+and write out a parser for that grammar in the C language.
+.Sh OPTIONS
+.Bl -tag -width indent
+.It Fl b
+Print only the basis in report.
+.It Fl c
+Don't compress the action table.
+.It Fl g
+Print grammar without actions.
+.It Fl m
+Output a makeheaders compatible file.
+.It Fl q
+(Quiet) Don't print the report file.
+.It Fl s
+Print parser stats to standard output.
+.It Fl x
+Print the version number.
+.El
+.Sh FILES
+.Bl -tag -width indent
+.It Pa /usr/share/lemon/lempar.c
+Driver template for the
+.Nm
+parser generator.
+.El
+.Sh AUTHOR
+.Nm
+has been written by
+.An D. Richard Hipp Aq drh@hwaci.com .
+.Pp
+This manual page was written by
+.An Guus Sliepen Aq guus@debian.org
+for the Debian GNU/Linux system.
